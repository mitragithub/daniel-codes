<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>emlddmm package &mdash; GDM 0.0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> GDM
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="coordinate_systems.html">Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="file_formats.html">File Formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="input_specification.html">Input specification via Transformation Graph Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="output_specification.html">Output Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="documentation.html">Function reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="todo.html">Work in progress</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">GDM</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>emlddmm package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/emlddmm.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="emlddmm-package">
<h1>emlddmm package<a class="headerlink" href="#emlddmm-package" title="Permalink to this heading"></a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading"></a></h2>
</div>
<div class="section" id="emlddmm-curve-annotator-module">
<h2>emlddmm.curve_annotator module<a class="headerlink" href="#emlddmm-curve-annotator-module" title="Permalink to this heading"></a></h2>
</div>
<div class="section" id="module-emlddmm.emlddmm">
<span id="emlddmm-emlddmm-module"></span><h2>emlddmm.emlddmm module<a class="headerlink" href="#module-emlddmm.emlddmm" title="Permalink to this heading"></a></h2>
<p>Run the EMLDDMM algorithm for deformable registration between two
different imaging modalities with possible missing data in one of them</p>
<p>Details of this algorithm can be found in</p>
<ul class="simple">
<li><p>[1] Tward, Daniel, et al. “Diffeomorphic registration with intensity transformation and missing data: Application to 3D digital pathology of Alzheimer’s disease.” Frontiers in neuroscience 14 (2020): 52.</p></li>
<li><p>[2] Tward, Daniel, et al. “3d mapping of serial histology sections with anomalies using a novel robust deformable registration algorithm.” Multimodal Brain Image Analysis and Mathematical Foundations of Computational Anatomy. Springer, Cham, 2019. 162-173.</p></li>
<li><p>[3] Tward, Daniel, et al. “Solving the where problem in neuroanatomy: a generative framework with learned mappings to register multimodal, incomplete data into a reference brain.” bioRxiv (2020).</p></li>
<li><p>[4] Tward DJ. An optical flow based left-invariant metric for natural gradient descent in affine image registration. Frontiers in Applied Mathematics and Statistics. 2021 Aug 24;7:718607.</p></li>
</ul>
<p>Note all parameters are keyword arguments, but the first four are required.</p>
<dl class="field-list simple">
<dt class="field-odd">param xI</dt>
<dd class="field-odd"><p>xI[i] stores the location of voxels on the i-th axis of the atlas image I (REQUIRED)</p>
</dd>
<dt class="field-even">type xI</dt>
<dd class="field-even"><p>list of arrays</p>
</dd>
<dt class="field-odd">param I</dt>
<dd class="field-odd"><p>4D array storing atlas imaging data.  Channels (e.g. RGB are stored on the
first axis, and the last three are spatial dimensions. (REQUIRED)</p>
</dd>
<dt class="field-even">type I</dt>
<dd class="field-even"><p>4D array (numpy or torch)</p>
</dd>
<dt class="field-odd">param xJ</dt>
<dd class="field-odd"><p>xJ[i] stores the location of voxels on the i-th axis of the target image J (REQUIRED)</p>
</dd>
<dt class="field-even">type xJ</dt>
<dd class="field-even"><p>list of arrays</p>
</dd>
<dt class="field-odd">param J</dt>
<dd class="field-odd"><p>4D array storing target imaging data.  Channels (e.g. RGB are stored on the
first axis, and the last three are spatial dimensions. (REQUIRED)</p>
</dd>
<dt class="field-even">type J</dt>
<dd class="field-even"><p>4D array (numpy or torch)</p>
</dd>
<dt class="field-odd">param nt</dt>
<dd class="field-odd"><p>Number of timesteps for integrating a velocity field to yeild a position field (default 5).</p>
</dd>
<dt class="field-even">type nt</dt>
<dd class="field-even"><p>int</p>
</dd>
<dt class="field-odd">param eA</dt>
<dd class="field-odd"><p>Gradient descent step size for affine component (default 1e-5).  It is strongly suggested
that you test this value and not rely on defaults. Note linear and translation components
are combined following [4] so only one stepsize is required.</p>
</dd>
<dt class="field-even">type eA</dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">param ev</dt>
<dd class="field-odd"><p>Gradient descent step size for affine component (default 1e-5).  It is strongly suggested
that you test this value and not rely on defaults.</p>
</dd>
<dt class="field-even">type ev</dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">param order</dt>
<dd class="field-odd"><p>Order of the polynomial used for contrast mapping. If using local contranst,
only order 1 is supported.</p>
</dd>
<dt class="field-even">type order</dt>
<dd class="field-even"><p>int</p>
</dd>
<dt class="field-odd">param n_draw</dt>
<dd class="field-odd"><p>Draw a picture every n_draw iterations. 0 for do not draw.</p>
</dd>
<dt class="field-even">type n_draw</dt>
<dd class="field-even"><p>int</p>
</dd>
<dt class="field-odd">param sigmaR</dt>
<dd class="field-odd"><p>Amount of regularization of the velocity field used for diffeomorphic transformation,
of the form 1/sigmaR^2 * (integral over time of norm velocity squared ).</p>
</dd>
<dt class="field-even">type sigmaR</dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">param n_iter</dt>
<dd class="field-odd"><p>How many iterations of optimization to run.</p>
</dd>
<dt class="field-even">type n_iter</dt>
<dd class="field-even"><p>int</p>
</dd>
<dt class="field-odd">param n_e_step</dt>
<dd class="field-odd"><p>How many iterations of M step to run before another E step is ran in
expectation maximization algorithm for detecting outliers.</p>
</dd>
<dt class="field-even">type n_e_step</dt>
<dd class="field-even"><p>int</p>
</dd>
<dt class="field-odd">param v_start</dt>
<dd class="field-odd"><p>What iteration to start optimizing velocity field.  One may want to compute an affine
transformation before beginning to compute a deformation (for example).</p>
</dd>
<dt class="field-even">type v_start</dt>
<dd class="field-even"><p>int</p>
</dd>
<dt class="field-odd">param n_reduce_step</dt>
<dd class="field-odd"><p>Simple stepsize reducer for gradient descent optimization. Every this number of steps,
we check if objective function is oscillating. If so we reduce the step size.</p>
</dd>
<dt class="field-even">type n_reduce_step</dt>
<dd class="field-even"><p>int</p>
</dd>
<dt class="field-odd">param v_expand_factor</dt>
<dd class="field-odd"><p>How much bigger than the atlas image should the domain of the velocity field be? This
is helpful to avoid wraparound effects caused by discrete Fourier domain calculations.
0.2 means 20% larger.</p>
</dd>
<dt class="field-even">type v_expand_factor</dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">param v_res_factor</dt>
<dd class="field-odd"><p>How much lower resolution should the velocity field be sampled at than the atlas image.
This is overrided if you specify dv.</p>
</dd>
<dt class="field-even">type v_res_factor</dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">param dv</dt>
<dd class="field-odd"><p>Explicitly state the resolution of the sampling grid for the velocity field.</p>
</dd>
<dt class="field-even">type dv</dt>
<dd class="field-even"><p>None or float or list of 3 floats</p>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>Constant with units of length.  In velocity regularization, its square is multiplied against the Laplacian.
Regularization is of the form 1/2/sigmaR^2 int <a href="#id1"><span class="problematic" id="id2">|</span></a>(id - a^2 Delta)^p v_t|^2_{L2} dt.</p>
</dd>
<dt class="field-even">type a</dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">param p</dt>
<dd class="field-odd"><p>Power of the Laplacian operator in regularization of the velocity field.
Regularization is of the form 1/2/sigmaR^2 int <a href="#id3"><span class="problematic" id="id4">|</span></a>(id - a^2 Delta)^p v_t|^2_{L2} dt.</p>
</dd>
<dt class="field-even">type p</dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">returns</dt>
<dd class="field-odd"><p><strong>out</strong> (<em>dict</em>) – Returns a dictionary of outputs storing computing transforms. if full_outputs==True,
then more data is output including figures.</p>
</dd>
<dt class="field-even">raises Exception</dt>
<dd class="field-even"><p>If the initial velocity does not have three components.</p>
</dd>
<dt class="field-odd">raises Exception</dt>
<dd class="field-odd"><p>Local contrast transform requires either order = 1, or order &gt; 1 and 1D atlas.</p>
</dd>
<dt class="field-even">raises Exception</dt>
<dd class="field-even"><p>If order &gt; 1. Local contrast transform not implemented yet except for linear.</p>
</dd>
<dt class="field-odd">raises Exception</dt>
<dd class="field-odd"><p>Amode must be 0 (normal), 1 (rigid), or 2 (rigid+scale), or 3 (rigid using XJ for projection).</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.emlddmm.__dir__">
<span class="sig-prename descclassname"><span class="pre">emlddmm.emlddmm.</span></span><span class="sig-name descname"><span class="pre">__dir__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emlddmm.emlddmm.__dir__" title="Permalink to this definition"></a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.emlddmm.__format__">
<span class="sig-prename descclassname"><span class="pre">emlddmm.emlddmm.</span></span><span class="sig-name descname"><span class="pre">__format__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format_spec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#emlddmm.emlddmm.__format__" title="Permalink to this definition"></a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.emlddmm.__init_subclass__">
<span class="sig-prename descclassname"><span class="pre">emlddmm.emlddmm.</span></span><span class="sig-name descname"><span class="pre">__init_subclass__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emlddmm.emlddmm.__init_subclass__" title="Permalink to this definition"></a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.emlddmm.__new__">
<span class="sig-prename descclassname"><span class="pre">emlddmm.emlddmm.</span></span><span class="sig-name descname"><span class="pre">__new__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#emlddmm.emlddmm.__new__" title="Permalink to this definition"></a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.emlddmm.__reduce__">
<span class="sig-prename descclassname"><span class="pre">emlddmm.emlddmm.</span></span><span class="sig-name descname"><span class="pre">__reduce__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emlddmm.emlddmm.__reduce__" title="Permalink to this definition"></a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.emlddmm.__reduce_ex__">
<span class="sig-prename descclassname"><span class="pre">emlddmm.emlddmm.</span></span><span class="sig-name descname"><span class="pre">__reduce_ex__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#emlddmm.emlddmm.__reduce_ex__" title="Permalink to this definition"></a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.emlddmm.__sizeof__">
<span class="sig-prename descclassname"><span class="pre">emlddmm.emlddmm.</span></span><span class="sig-name descname"><span class="pre">__sizeof__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emlddmm.emlddmm.__sizeof__" title="Permalink to this definition"></a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.emlddmm.__subclasshook__">
<span class="sig-prename descclassname"><span class="pre">emlddmm.emlddmm.</span></span><span class="sig-name descname"><span class="pre">__subclasshook__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emlddmm.emlddmm.__subclasshook__" title="Permalink to this definition"></a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

</div>
<div class="section" id="emlddmm-histsetup-module">
<h2>emlddmm.histsetup module<a class="headerlink" href="#emlddmm-histsetup-module" title="Permalink to this heading"></a></h2>
</div>
<div class="section" id="emlddmm-load-image-folder-module">
<h2>emlddmm.load_image_folder module<a class="headerlink" href="#emlddmm-load-image-folder-module" title="Permalink to this heading"></a></h2>
</div>
<div class="section" id="emlddmm-manual-point-align-module">
<h2>emlddmm.manual_point_align module<a class="headerlink" href="#emlddmm-manual-point-align-module" title="Permalink to this heading"></a></h2>
</div>
<div class="section" id="emlddmm-point-mapper-module">
<h2>emlddmm.point_mapper module<a class="headerlink" href="#emlddmm-point-mapper-module" title="Permalink to this heading"></a></h2>
</div>
<div class="section" id="emlddmm-setup-module">
<h2>emlddmm.setup module<a class="headerlink" href="#emlddmm-setup-module" title="Permalink to this heading"></a></h2>
</div>
<div class="section" id="emlddmm-transformation-graph-v01-module">
<h2>emlddmm.transformation_graph_v01 module<a class="headerlink" href="#emlddmm-transformation-graph-v01-module" title="Permalink to this heading"></a></h2>
</div>
<div class="section" id="emlddmm-twodreg-module">
<h2>emlddmm.twoDreg module<a class="headerlink" href="#emlddmm-twodreg-module" title="Permalink to this heading"></a></h2>
</div>
<div class="section" id="module-emlddmm">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-emlddmm" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="emlddmm.Image">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">Image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">space</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fpath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#Image"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.Image" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="emlddmm.Image.space">
<span class="sig-name descname"><span class="pre">space</span></span><a class="headerlink" href="#emlddmm.Image.space" title="Permalink to this definition"></a></dt>
<dd><p>name of the image space</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="emlddmm.Image.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#emlddmm.Image.name" title="Permalink to this definition"></a></dt>
<dd><p>image name. This is provided when instantiating an Image object.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="emlddmm.Image.x">
<span class="sig-name descname"><span class="pre">x</span></span><a class="headerlink" href="#emlddmm.Image.x" title="Permalink to this definition"></a></dt>
<dd><p>image voxel coordinates</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of numpy arrays</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="emlddmm.Image.data">
<span class="sig-name descname"><span class="pre">data</span></span><a class="headerlink" href="#emlddmm.Image.data" title="Permalink to this definition"></a></dt>
<dd><p>image data</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="emlddmm.Image.title">
<span class="sig-name descname"><span class="pre">title</span></span><a class="headerlink" href="#emlddmm.Image.title" title="Permalink to this definition"></a></dt>
<dd><p>image title passed by the read_data function</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="emlddmm.Image.names">
<span class="sig-name descname"><span class="pre">names</span></span><a class="headerlink" href="#emlddmm.Image.names" title="Permalink to this definition"></a></dt>
<dd><p>information about image data dimensions</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of strings</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="emlddmm.Image.mask">
<span class="sig-name descname"><span class="pre">mask</span></span><a class="headerlink" href="#emlddmm.Image.mask" title="Permalink to this definition"></a></dt>
<dd><p>image mask</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="emlddmm.Image.path">
<span class="sig-name descname"><span class="pre">path</span></span><a class="headerlink" href="#emlddmm.Image.path" title="Permalink to this definition"></a></dt>
<dd><p>path to image file or directory containing the 2D image series</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="emlddmm.Image.normalize">
<span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.99</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#emlddmm.Image.normalize" title="Permalink to this definition"></a></dt>
<dd><p>normalize image</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="emlddmm.Image.downsample">
<span class="sig-name descname"><span class="pre">downsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">down</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#Image.downsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.Image.downsample" title="Permalink to this definition"></a></dt>
<dd><p>downsample image, image coordinated, and mask</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="emlddmm.Image.fnames">
<span class="sig-name descname"><span class="pre">fnames</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#Image.fnames"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.Image.fnames" title="Permalink to this definition"></a></dt>
<dd><p>get filenames of 2D images in a series, or return the single filename of an image volume</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id0">
<span class="sig-name descname"><span class="pre">downsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">down</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#Image.downsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id0" title="Permalink to this definition"></a></dt>
<dd><p>Downsample image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>down</strong> (<em>list</em><em> of </em><em>ints</em>) – Factor by which to downsample along each dimension</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>x</strong> (<em>list of numpy arrays</em>) – Pixel locations where each element of the list identifies pixel
locations in corresponding axis.</p></li>
<li><p><strong>data</strong> (<em>numpy array</em>) – image data</p></li>
<li><p><strong>mask</strong> (<em>numpy array</em>) – binary mask array</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id5">
<span class="sig-name descname"><span class="pre">fnames</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#Image.fnames"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id5" title="Permalink to this definition"></a></dt>
<dd><p>Get a list of image file names for 2D series, or a single file name for volume image.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>fnames</strong> (<em>list of strings</em>) – List of image file names</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="emlddmm.Transform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">Transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'f'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.float32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cpu'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#Transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.Transform" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A simple class for storing and applying transforms</p>
<p>Note that the types of transforms we can support are</p>
<ol class="arabic simple">
<li><p>Deformations stored as a displacement field loaded from a vtk file.  These should be a 1x3xrowxcolxslice array.</p></li>
<li><p>Deformations stored as a position field in a python variable. These are a 3xrowxcolxslice array.</p></li>
<li><p>Velocity fields stored as a python variable. These are ntx3xrowxcolxslice arrays.</p></li>
<li><p>a 4x4 affine transform loaded from a text file.</p></li>
<li><p>a 4x4 affine transform stored in a python variable</p></li>
<li><p>a nslices x 3 x 3 sequence of affine transforms stored in an array. <strong>* new and special case *</strong></p></li>
</ol>
<p>Note the data stores position fields or matrices.  If it is a vtk file it will store a position field.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Exception</strong> – If transform is not a txt or vtk file or valid python variable.</p></li>
<li><p><strong>Exception</strong> – if direction is not ‘f’ or ‘b’.</p></li>
<li><p><strong>Exception</strong> – When inputting a velocity field, if the domain is not included.</p></li>
<li><p><strong>Exception</strong> – When inputting a matrix, if its shape is not 3x3 or 4x4.</p></li>
<li><p><strong>Exception</strong> – When specifying a mapping, if the direction is ‘b’ (backward).</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="emlddmm.Transform.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#Transform.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.Transform.apply" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.affine_from_figure">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">affine_from_figure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#affine_from_figure"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.affine_from_figure" title="Permalink to this definition"></a></dt>
<dd><p>Build small affine transforms by looking at figures generated in draw.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>str</em>) – <p>Two letters. “t”,”m”,”b” for top row middle row bottom row.</p>
<p>Then ‘w’,’e’,’n’,’s’ for left right up down</p>
<p>Or ‘r’,’l’ for turn right turn left</p>
<p>or ‘id’ for identity.</p>
</p></li>
<li><p><strong>shift</strong> (<em>float</em>) – How far to shift.</p></li>
<li><p><strong>angle</strong> (<em>float</em>) – How far to rotate (in degrees)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>A0</strong> (<em>numpy array</em>) – 4x4 numpy array affine transform matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.apply_transform_float">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">apply_transform_float</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xout</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#apply_transform_float"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.apply_transform_float" title="Permalink to this definition"></a></dt>
<dd><p>Apply transform to image
Image points stored in x, data stored in I
transform stored in Xout</p>
<p>There is an issue with numpy integer arrays, I’ll have two functions</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.apply_transform_from_file_to_points">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">apply_transform_from_file_to_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tform_file</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#apply_transform_from_file_to_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.apply_transform_from_file_to_points" title="Permalink to this definition"></a></dt>
<dd><p>To transform points from spacei to spacej (example from fluoro to nissl_registerd)
We look for the output folder called
outputs/spacei/spacej_to_spacei/transforms (example outputs/fluoro/nissl_registered_to_fluoro/transforms)
Note “spacej to spacei” is not a typo
(even though it looks backwards, point data uses inverse of transform as compared to images).
In the transforms folder, there are transforms of the form
“spacei to spacej”.
If applying transforms to slice data, you will have to find the appropriate slice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> (<em>numpy array</em>) – A Nx3 numpy array of coordinates in slice,row,col order</p></li>
<li><p><strong>tform_file</strong> (<em>str</em>) – A string pointing to a transform file</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Tq</strong> (<em>numpy array</em>) – The transformed set of points.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.apply_transform_int">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">apply_transform_int</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xout</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">double</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#apply_transform_int"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.apply_transform_int" title="Permalink to this definition"></a></dt>
<dd><p>Apply transform to image
Image points stored in x, data stored in I
transform stored in Xout</p>
<p>There is an issue with numpy integer arrays, I’ll have two functions</p>
<p>Note that we often require double precision when converting to floats and back</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>Exception</strong> – If mode is not ‘nearest’ for ints.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.atlas_free_reconstruction">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">atlas_free_reconstruction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#atlas_free_reconstruction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.atlas_free_reconstruction" title="Permalink to this definition"></a></dt>
<dd><p>Atlas free slice alignment</p>
<p>Uses an MM algorithm to align slices.  Minimizes a Sobolev norm over rigid transformations of each slice.</p>
<p>All arguments are keword arguments</p>
<div class="section" id="keword-arguments">
<h3>Keword Arguments<a class="headerlink" href="#keword-arguments" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>xJ<span class="classifier">list of arrays</span></dt><dd><p>Lists of pixel locations in slice row col axes</p>
</dd>
<dt>J<span class="classifier">array</span></dt><dd><p>A C x slice x row x col set of 2D image.</p>
</dd>
<dt>W<span class="classifier">array</span></dt><dd><p>A slice x row x col set of weights of 2D images.  1 for good quality, to 0 for bad quality or out of bounds.</p>
</dd>
<dt>a<span class="classifier">float</span></dt><dd><p>length scale (multiplied by laplacian) for smootheness averaging between slices. Defaults to twice the slice separation.</p>
</dd>
<dt>p<span class="classifier">float</span></dt><dd><p>Power of laplacian in somothing. Defaults to 2.</p>
</dd>
<dt>draw<span class="classifier">int</span></dt><dd><p>Draw figure (default false)</p>
</dd>
<dt>n_steps<span class="classifier">int</span></dt><dd><p>Number of iterations of MM algorithm.</p>
</dd>
<dt><a href="#id6"><span class="problematic" id="id7">**</span></a>kwargs<span class="classifier">dict</span></dt><dd><p>All other keword arguments are passed along to slice matching in the emlddmm algorithm.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>out</strong> (<em>dictionary</em>) – All outputs from emlddmm algorithm, plus the new image I, and reconstructed image Jr</p></li>
<li><p><strong>out[‘I’]</strong> (<em>numpy array</em>) – A C x slice x row x col set of 2D images (same size as J), averaged between slices.</p></li>
<li><p><strong>out[‘Jr’]</strong> (<em>numpy array</em>) – A C x slice x row x col set of 2D images (same size as J)</p></li>
</ul>
</dd>
</dl>
<div class="admonition-todo admonition" id="id8">
<p class="admonition-title">Todo</p>
<p>Think about how to do this with some slices fixed.
Think about normalizing slice to slice contrast.</p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.compose_sequence">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">compose_sequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transforms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'f'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#compose_sequence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.compose_sequence" title="Permalink to this definition"></a></dt>
<dd><p>Compose a set of transformations, to produce a single position field,
suitable for use with <a class="reference internal" href="#emlddmm.apply_transform_float" title="emlddmm.apply_transform_float"><code class="xref py py-func docutils literal notranslate"><span class="pre">emlddmm.apply_transform_float()</span></code></a> for example.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transforms</strong> – <p>Several types of inputs are supported.</p>
<ol class="arabic simple">
<li><p>A list of transforms class.</p></li>
<li><p>A list of filenames (single direction in argument)</p></li>
<li><p>A list of a list of 2 tuples that specify direction (f,b)</p></li>
<li><p>An output directory</p></li>
</ol>
</p></li>
<li><p><strong>Xin</strong> (<em>3 x slice x row x col array</em>) – The points we want to transform (e.g. sample points in atlas).  Also supports input as a list of voxel locations,
along each axis which will be reshaped as above using meshgrid.</p></li>
<li><p><strong>direction</strong> (<em>char</em>) – Can be ‘f’ for foward or ‘b’ for bakward.  f is default which maps points from atlas to target,
or images from target to atlas.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Xout</strong> (<em>3 x slicex rowxcol array</em>) – Points from Xin that have had a sequence of transformations applied to them.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note, if the input is a string, we assume it is an output directory and get A and V. In this case we use the direction argument.
If the input is a tuple of length 2, we assume it is an output directory and a direction</p>
<p>Otherwise, the input must be a list.  It can be a list of strings, or transforms, or string-direction tuples.</p>
<p>We check that it is an instace of a list, so it should not be a tuple.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>Exception</strong> – Transforms must be either output directory,
    or list of objects, or list of filenames,
    or list of tuples storing filename/direction.</p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id9">
<p class="admonition-title">Todo</p>
<ol class="arabic simple">
<li><p>use os path join</p></li>
<li><p>support direction as a list, right now direction only is used for a single direction</p></li>
</ol>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.compute_atlas_from_slices">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">compute_atlas_from_slices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ooop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">draw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#compute_atlas_from_slices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.compute_atlas_from_slices" title="Permalink to this definition"></a></dt>
<dd><p>Construct an atlas image by averaging between slices.</p>
<p>This uses an MM (also could be interpreted as EM) algorithm for
converting a weighted least squares problem to an ordinary least squares problem.
The latter can be solved as a stationary problem, and updated iteratively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>J</strong> (<em>array</em>) – an C x slice x row x col image array.</p></li>
<li><p><strong>W</strong> (<em>array</em>) – An slice x row x col array of weights</p></li>
<li><p><strong>ooop</strong> (<em>array</em>) – a 1D array with “slice” elements.  This is a frequency domain
one over operator for doing smoothing.</p></li>
<li><p><strong>niter</strong> (<em>int</em>) – Number of iterations to update in MM algorithm. (default to 10)</p></li>
<li><p><strong>I</strong> (<em>array</em>) – An C x slice x row x col image array representing an initial guess.</p></li>
<li><p><strong>draw</strong> (<em>int</em>) – Draw the image every draw iterations.  Do not draw if 0 (default).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This code uses numpy, not torch, since it is not gradient based.</p>
</div>
<div class="admonition-todo admonition" id="id10">
<p class="admonition-title">Todo</p>
<p>Better boundary conditions</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.convert_points_from_json">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">convert_points_from_json</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_high</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_high</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sidecar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#convert_points_from_json"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.convert_points_from_json" title="Permalink to this definition"></a></dt>
<dd><p>We load points from a json produced by Samik at cold spring harbor.</p>
<p>These are indexed to pixels in a high res image, rather than any physical units.</p>
<p>To convert to proper points in 3D for transforming, we need information about pixel size and origin.</p>
<p>Pixel size of the high res image is a required input.</p>
<p>If we have a json sidecar file that was prepared for the registration dataset, we can get all the info from this.</p>
<p>If not, we get it elsewhere.</p>
<p>Origin information can be determined from knowing the number of pixels in the high res image.</p>
<p>Z coordinate information is not required if we are only applying 2D transforms,
but for 3D it will have to be input manually if we do not have a sidecar file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>str</em><em> or </em><em>numpy array</em>) – either a geojson filename, or a Nx2 numpy array with coordinates loaded from such a file.</p></li>
<li><p><strong>d_high</strong> (<em>float</em>) – pixel size of high resolution image where cells were detected</p></li>
<li><p><strong>n_high</strong> (<em>str</em><em> or </em><em>numpy array</em>) – WIDTH x HEIGHT of high res image.  Or the filename of the high res image.</p></li>
<li><p><strong>sidecar</strong> (<em>str</em>) – Filename of sidecar file to get z and origin info</p></li>
<li><p><strong>z</strong> (<em>float</em>) – z coordinate</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>q</strong> (<em>numpy array</em>) – A Nx3 array of points in physical units using our coordinate system convention (origin in center).</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If we are applying 3D transforms, we need a z coordinate.  This can be determined either by specifying it
or by using a sidecar file.  If we have neither, it ill be set to 0.</p>
<div class="admonition-todo admonition" id="id11">
<p class="admonition-title">Todo</p>
<p>Consider setting z to nan instead of zero.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.downmedian">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">downmedian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xI</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">down</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#downmedian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.downmedian" title="Permalink to this definition"></a></dt>
<dd><p>Downsamples a 3D image by taking the median among rectangular neighborhoods.
This is often appropriate when image pixels has a small number of outliers, or when
pixel values are assumed to be ordered, but don’t otherwise belong to a vector space.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>2D images can be hanled by adding a singleton dimension
no leading batch dimensions</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xI</strong> (<em>list</em><em> of </em><em>3 numpy arrays</em>) – Locations of image pixels along each axis</p></li>
<li><p><strong>S</strong> (<em>numpy array</em>) – Numpy array storing imaging data.  Note there should not be
a leading dimension for channels.</p></li>
<li><p><strong>down</strong> (<em>list</em><em> of </em><em>3 ints</em>) – downsample by this factor along each axis.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>xd</strong> (<em>list of 3 numpy arrays</em>) – Locations of image pixels along each axis after downsampling.</p></li>
<li><p><strong>Sd</strong> (<em>numpy array</em>) – The downsampled image.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.downmode">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">downmode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xI</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">down</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#downmode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.downmode" title="Permalink to this definition"></a></dt>
<dd><p>Downsamples a 3D image by taking the mode among rectangular neighborhoods.
This is appropriate for label images, where averaging pixel values is not meaningful.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>2D images can be hanled by adding a singleton dimension
no leading batch dimensions</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xI</strong> (<em>list</em><em> of </em><em>3 numpy arrays</em>) – Locations of image pixels along each axis</p></li>
<li><p><strong>S</strong> (<em>numpy array</em>) – Numpy array storing imaging data.  Note there should not be
a leading dimension for channels.</p></li>
<li><p><strong>down</strong> (<em>list</em><em> of </em><em>3 ints</em>) – downsample by this factor along each axis.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>xd</strong> (<em>list of 3 numpy arrays</em>) – Locations of image pixels along each axis after downsampling.</p></li>
<li><p><strong>Sd</strong> (<em>numpy array</em>) – The downsampled image.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.downsample">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">downsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">down</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#downsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.downsample" title="Permalink to this definition"></a></dt>
<dd><p>Downsample an image by an integer factor along each axis. Note extra data at
the end will be truncated if necessary.</p>
<p>If the first axis is for image channels, downsampling factor should be 1 on this.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>I</strong> (<em>array</em><em> (</em><em>numpy</em><em> or </em><em>torch</em><em>)</em>) – Imaging data to downsample</p></li>
<li><p><strong>down</strong> (<em>list</em><em> of </em><em>int</em>) – List of downsampling factors for each axis.</p></li>
<li><p><strong>W</strong> (<em>array</em><em> (</em><em>numpy</em><em> or </em><em>torch</em><em>)</em>) – A weight of the same size as I but without the “channel” dimension</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Id</strong> (<em>array (numpy or torch as input)</em>) – Downsampled imaging data.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.downsample_ax">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">downsample_ax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">down</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#downsample_ax"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.downsample_ax" title="Permalink to this definition"></a></dt>
<dd><p>Downsample imaging data along one of the first 5 axes.</p>
<p>Imaging data is downsampled by averaging nearest pixels.
Note that data will be lost from the end of images instead of padding.
This function is generally called repeatedly on each axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>I</strong> (<em>array like</em><em> (</em><em>numpy</em><em> or </em><em>torch</em><em>)</em>) – Image to be downsampled on one axis.</p></li>
<li><p><strong>down</strong> (<em>int</em>) – Downsampling factor.  2 means average pairs of nearest pixels
into one new downsampled pixel</p></li>
<li><p><strong>ax</strong> (<em>int</em>) – Which axis to downsample along.</p></li>
<li><p><strong>W</strong> (<em>np array</em>) – A mask the same size as I, but without a “channel” dimension</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Id</strong> (<em>array like</em>) – The downsampled image.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>Exception</strong> – If a mask (W) is included and ax == 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.downsample_image_domain">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">downsample_image_domain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xI</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">down</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#downsample_image_domain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.downsample_image_domain" title="Permalink to this definition"></a></dt>
<dd><p>Downsample an image as well as pixel locations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xI</strong> (<em>list</em><em> of </em><em>numpy arrays</em>) – xI[i] is a numpy array storing the locations of each voxel
along the i-th axis.</p></li>
<li><p><strong>I</strong> (<em>array like</em>) – Image to be downsampled</p></li>
<li><p><strong>down</strong> (<em>list</em><em> of </em><em>ints</em>) – Factor by which to downsample along each dimension</p></li>
<li><p><strong>W</strong> (<em>array like</em>) – Weights the same size as I, but without a “channel” dimension</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>xId</strong> (<em>list of numpy arrays</em>) – New voxel locations in the same format as xI</p></li>
<li><p><strong>Id</strong> (<em>numpy array</em>) – Downsampled image.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>Exception</strong> – If the length of down and xI are not equal.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.draw">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">draw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xJ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_slices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slices_start_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#draw"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.draw" title="Permalink to this definition"></a></dt>
<dd><p>Draw 3D imaging data.</p>
<p>Images are shown by sampling slices along 3 orthogonal axes.
Color or grayscale data can be shown.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>J</strong> (<em>array like</em><em> (</em><em>torch tensor</em><em> or </em><em>numpy array</em><em>)</em>) – A 3D image with C channels should be size (C x nslice x nrow x ncol)
Note grayscale images should have C=1, but still be a 4D array.</p></li>
<li><p><strong>xJ</strong> (<em>list</em>) – A list of 3 numpy arrays.  xJ[i] contains the positions of voxels
along axis i.  Note these are assumed to be uniformly spaced. The default
is voxels of size 1.0.</p></li>
<li><p><strong>fig</strong> (<em>matplotlib figure</em>) – A figure in which to draw pictures. Contents of the figure will be cleared.
Default is None, which creates a new figure.</p></li>
<li><p><strong>n_slices</strong> (<em>int</em>) – An integer denoting how many slices to draw along each axis. Default 5.</p></li>
<li><p><strong>vmin</strong> – A minimum value for windowing imaging data. Can also be a list of size C for
windowing each channel separately. Defaults to None, which corresponds
to tha 0.001 quantile on each channel.</p></li>
<li><p><strong>vmax</strong> – A maximum value for windowing imaging data. Can also be a list of size C for
windowing each channel separately. Defaults to None, which corresponds
to tha 0.999 quantile on each channel.</p></li>
<li><p><strong>disp</strong> (<em>bool</em>) – Figure display toggle</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – Other keywords will be passed on to the matplotlib imshow function. For example
include cmap=’gray’ for a gray colormap</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>fig</strong> (<em>matplotlib figure</em>) – The matplotlib figure variable with data.</p></li>
<li><p><strong>axs</strong> (<em>array of matplotlib axes</em>) – An array of matplotlib subplot axes containing each image.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Here is an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">example</span> <span class="n">test</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="id12">
<p class="admonition-title">Todo</p>
<p>Put interpolation=’none’ in keywords</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.emlddmm">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">emlddmm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#emlddmm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.emlddmm" title="Permalink to this definition"></a></dt>
<dd><p>Run the EMLDDMM algorithm for deformable registration between two
different imaging modalities with possible missing data in one of them</p>
<p>Details of this algorithm can be found in</p>
<ul class="simple">
<li><p>[1] Tward, Daniel, et al. “Diffeomorphic registration with intensity transformation and missing data: Application to 3D digital pathology of Alzheimer’s disease.” Frontiers in neuroscience 14 (2020): 52.</p></li>
<li><p>[2] Tward, Daniel, et al. “3d mapping of serial histology sections with anomalies using a novel robust deformable registration algorithm.” Multimodal Brain Image Analysis and Mathematical Foundations of Computational Anatomy. Springer, Cham, 2019. 162-173.</p></li>
<li><p>[3] Tward, Daniel, et al. “Solving the where problem in neuroanatomy: a generative framework with learned mappings to register multimodal, incomplete data into a reference brain.” bioRxiv (2020).</p></li>
<li><p>[4] Tward DJ. An optical flow based left-invariant metric for natural gradient descent in affine image registration. Frontiers in Applied Mathematics and Statistics. 2021 Aug 24;7:718607.</p></li>
</ul>
<p>Note all parameters are keyword arguments, but the first four are required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xI</strong> (<em>list</em><em> of </em><em>arrays</em>) – xI[i] stores the location of voxels on the i-th axis of the atlas image I (REQUIRED)</p></li>
<li><p><strong>I</strong> (<em>4D array</em><em> (</em><em>numpy</em><em> or </em><em>torch</em><em>)</em>) – 4D array storing atlas imaging data.  Channels (e.g. RGB are stored on the
first axis, and the last three are spatial dimensions. (REQUIRED)</p></li>
<li><p><strong>xJ</strong> (<em>list</em><em> of </em><em>arrays</em>) – xJ[i] stores the location of voxels on the i-th axis of the target image J (REQUIRED)</p></li>
<li><p><strong>J</strong> (<em>4D array</em><em> (</em><em>numpy</em><em> or </em><em>torch</em><em>)</em>) – 4D array storing target imaging data.  Channels (e.g. RGB are stored on the
first axis, and the last three are spatial dimensions. (REQUIRED)</p></li>
<li><p><strong>nt</strong> (<em>int</em>) – Number of timesteps for integrating a velocity field to yeild a position field (default 5).</p></li>
<li><p><strong>eA</strong> (<em>float</em>) – Gradient descent step size for affine component (default 1e-5).  It is strongly suggested
that you test this value and not rely on defaults. Note linear and translation components
are combined following [4] so only one stepsize is required.</p></li>
<li><p><strong>ev</strong> (<em>float</em>) – Gradient descent step size for affine component (default 1e-5).  It is strongly suggested
that you test this value and not rely on defaults.</p></li>
<li><p><strong>order</strong> (<em>int</em>) – Order of the polynomial used for contrast mapping. If using local contranst,
only order 1 is supported.</p></li>
<li><p><strong>n_draw</strong> (<em>int</em>) – Draw a picture every n_draw iterations. 0 for do not draw.</p></li>
<li><p><strong>sigmaR</strong> (<em>float</em>) – Amount of regularization of the velocity field used for diffeomorphic transformation,
of the form 1/sigmaR^2 * (integral over time of norm velocity squared ).</p></li>
<li><p><strong>n_iter</strong> (<em>int</em>) – How many iterations of optimization to run.</p></li>
<li><p><strong>n_e_step</strong> (<em>int</em>) – How many iterations of M step to run before another E step is ran in
expectation maximization algorithm for detecting outliers.</p></li>
<li><p><strong>v_start</strong> (<em>int</em>) – What iteration to start optimizing velocity field.  One may want to compute an affine
transformation before beginning to compute a deformation (for example).</p></li>
<li><p><strong>n_reduce_step</strong> (<em>int</em>) – Simple stepsize reducer for gradient descent optimization. Every this number of steps,
we check if objective function is oscillating. If so we reduce the step size.</p></li>
<li><p><strong>v_expand_factor</strong> (<em>float</em>) – How much bigger than the atlas image should the domain of the velocity field be? This
is helpful to avoid wraparound effects caused by discrete Fourier domain calculations.
0.2 means 20% larger.</p></li>
<li><p><strong>v_res_factor</strong> (<em>float</em>) – How much lower resolution should the velocity field be sampled at than the atlas image.
This is overrided if you specify dv.</p></li>
<li><p><strong>dv</strong> (<em>None</em><em> or </em><em>float</em><em> or </em><em>list</em><em> of </em><em>3 floats</em>) – Explicitly state the resolution of the sampling grid for the velocity field.</p></li>
<li><p><strong>a</strong> (<em>float</em>) – Constant with units of length.  In velocity regularization, its square is multiplied against the Laplacian.
Regularization is of the form 1/2/sigmaR^2 int <a href="#id13"><span class="problematic" id="id14">|</span></a>(id - a^2 Delta)^p v_t|^2_{L2} dt.</p></li>
<li><p><strong>p</strong> (<em>float</em>) – Power of the Laplacian operator in regularization of the velocity field.
Regularization is of the form 1/2/sigmaR^2 int <a href="#id15"><span class="problematic" id="id16">|</span></a>(id - a^2 Delta)^p v_t|^2_{L2} dt.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> (<em>dict</em>) – Returns a dictionary of outputs storing computing transforms. if full_outputs==True,
then more data is output including figures.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Exception</strong> – If the initial velocity does not have three components.</p></li>
<li><p><strong>Exception</strong> – Local contrast transform requires either order = 1, or order &gt; 1 and 1D atlas.</p></li>
<li><p><strong>Exception</strong> – If order &gt; 1. Local contrast transform not implemented yet except for linear.</p></li>
<li><p><strong>Exception</strong> – Amode must be 0 (normal), 1 (rigid), or 2 (rigid+scale), or 3 (rigid using XJ for projection).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.emlddmm_multiscale">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">emlddmm_multiscale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#emlddmm_multiscale"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.emlddmm_multiscale" title="Permalink to this definition"></a></dt>
<dd><p>Run the emlddmm algorithm multiple times, restarting
with the results of the previous iteration. This is intended
to be used to register data from coarse to fine resolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<em>emlddmm parameters either as a list</em><em> of </em><em>length 1</em><em> (</em><em>to use the same</em>) – </p></li>
<li><p><strong>at</strong> (<em>at each iteration</em><em>) or </em><em>a list</em><em> of </em><em>length N</em><em> (</em><em>to use different values</em>) – </p></li>
<li><p><strong>iterations</strong><strong>)</strong><strong>.</strong> (<em>each</em><em> of </em><em>the N</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>A list of emlddmm outputs (see documentation for emlddmm)</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.extent_from_x">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">extent_from_x</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xJ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#extent_from_x"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.extent_from_x" title="Permalink to this definition"></a></dt>
<dd><p>Given a set of pixel locations, returns an extent 4-tuple for use with imshow.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note inputs are locations of pixels along each axis, i.e. row column not xy.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>xJ</strong> (<em>list</em><em> of </em><em>torch tensors</em>) – Location of pixels along each axis</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>extent</strong> (<em>tuple</em>) – (xmin, xmax, ymin, ymax) tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Draw a 2D image stored in J, with pixel locations of rows stored in xJ[0] and pixel locations
of columns stored in xJ[1].</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extent_from_x</span><span class="p">(</span><span class="n">xJ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">extent</span><span class="o">=</span><span class="n">extentJ</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.find_bounding_box">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">find_bounding_box</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ji</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">startoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">search</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bbox</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#find_bounding_box"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.find_bounding_box" title="Permalink to this definition"></a></dt>
<dd><p>Computes a bounding box using an Otsu intraclass variance objective function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Ji</strong> (<em>numpy array</em>) – Row x col x n_channels numpy array to find bounding box</p></li>
<li><p><strong>startoff</strong> (<em>int</em>) – How far away from boundary to put initial guess.  Default 30.</p></li>
<li><p><strong>search</strong> (<em>int</em>) – How far to move bounding box edges at each iteration.  Default +/- 10.</p></li>
<li><p><strong>n_iter</strong> (<em>int</em>) – How many loops through top, left, bottom, right.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>bbox</strong> (<em>list</em>) – A tuple of 4 ints. [row0, col0, row1, col1].</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.fnames">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">fnames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#fnames"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.fnames" title="Permalink to this definition"></a></dt>
<dd><p>Get a list of image file names for 2D series, or a single file name for volume image.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>fnames</strong> (<em>list of strings</em>) – List of image file names</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.initialize_A2d_with_bbox">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">initialize_A2d_with_bbox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xJ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#initialize_A2d_with_bbox"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.initialize_A2d_with_bbox" title="Permalink to this definition"></a></dt>
<dd><p>Use bounding boxes to find an initial guess of A2d.</p>
<p>On each slice we will compute a bounding box.</p>
<p>Then we will compute a translation vector which will move the slice to the center of the field of view.</p>
<p>Then we will return the inverse.</p>
<p>TODO</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.interp">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">interp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phii</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp2d</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#interp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.interp" title="Permalink to this definition"></a></dt>
<dd><p>Interpolate an image with specified regular voxel locations at specified sample points.</p>
<p>Interpolate the image I, with regular grid positions stored in x (1d arrays),
at the positions stored in phii (3D or 4D arrays with first channel storing component)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>list</em><em> of </em><em>numpy arrays</em>) – x[i] is a numpy array storing the pixel locations of imaging data along the i-th axis.
Note that this MUST be regularly spaced, only the first and last values are queried.</p></li>
<li><p><strong>I</strong> (<em>array</em>) – Numpy array or torch tensor storing 2D or 3D imaging data.  In the 3D case, I is a 4D array with
channels along the first axis and spatial dimensions along the last 3. For 2D, I is a 3D array with
spatial dimensions along the last 2.</p></li>
<li><p><strong>phii</strong> (<em>array</em>) – Numpy array or torch tensor storing positions of the sample points. phii is a 3D or 4D array
with components along the first axis (e.g. x0,x1,x1) and spatial dimensions
along the last axes.</p></li>
<li><p><strong>interp2d</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, interpolates a 2D image, otherwise 3D. Default is False (expects a 3D image).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – keword arguments to be passed to the grid sample function. For example
to specify interpolation type like nearest.  See pytorch grid_sample documentation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> (<em>torch tensor</em>) – Array storing an image with channels stored along the first axis.
This is the input image resampled at the points stored in phii.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.labels_to_rgb">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">labels_to_rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">black_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">white_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#labels_to_rgb"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.labels_to_rgb" title="Permalink to this definition"></a></dt>
<dd><p>Convert an integer valued label image into a randomly colored image
for visualization with the draw function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>S</strong> (<em>numpy array</em>) – An array storing integer labels.  Expected to be 4D (1 x slices x rows x columns),
but can be 3D (slices x rows x columns).</p></li>
<li><p><strong>seed</strong> (<em>int</em>) – Random seed for reproducibility</p></li>
<li><p><strong>black_label</strong> (<em>int</em>) – Color to assign black.  Usually for background.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.load_slices">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">load_slices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xJ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#load_slices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.load_slices" title="Permalink to this definition"></a></dt>
<dd><p>Load a slice dataset.</p>
<p>Load a slice dataset for histology registration. Slice datasets include pairs
of images and json sidecar files, as well as one tsv file explaining the dataset.
Note this code creates a 3D array by padding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_name</strong> (<em>string</em>) – Name of a directory containing slice dataset.</p></li>
<li><p><strong>xJ</strong> (<em>list</em><em>, </em><em>optional</em>) – list of numpy arrays containing voxel positions along each axis.
Images will be resampled by interpolation on this 3D grid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>xJ</strong> (<em>list of numpy arrays</em>) – Location of v</p></li>
<li><p><strong>J</strong> (<em>numpy array</em>) – Numpy array of size C x nslices x nrows x ncols where C is the number of channels
e.g. C=3 for RGB.</p></li>
<li><p><strong>W0</strong> (<em>numpy array</em>) – A nslices x nrows x ncols numpy array containing weights.  Weights are 0 where there
was padding</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>Exception</strong> – If the first image is not present in the image series.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.map_image">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">map_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">emlddmm_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_space_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_space_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_image_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_image_directory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_slice_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_slice_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_detjac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#map_image"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.map_image" title="Permalink to this definition"></a></dt>
<dd><p>This function will map imaging data from one space to another.</p>
<p>There are four cases:</p>
<ol class="arabic simple">
<li><p>3D to 3D mapping: A single displacement field is used to map data</p></li>
<li><p>3D to 2D mapping: A single displacement field is used to map data, a slice filename is needed in addition to a space</p></li>
<li><p>2D to 2D mapping: A single matrix is used to map data.</p></li>
<li><p>2D to 3D mapping: Currently not supported. Ideally this will output data, and weights for a single slice, so it can be averaged with other slices.</p></li>
</ol>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function was built for a particular use case at Cold Spring Harbor, and is generally not used.
It may be removed in the future.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>emlddmm_path</strong> (<em>str</em>) – Path to the emlddmm python library, used for io</p></li>
<li><p><strong>root_dir</strong> (<em>str</em>) – The root directory of the output structure</p></li>
<li><p><strong>from_space_name</strong> (<em>str</em>) – The name of the space we are mapping data from</p></li>
<li><p><strong>to_space_name</strong> (<em>str</em>) – The name of the space we are mapping data to</p></li>
<li><p><strong>input_image_fname</strong> (<em>str</em>) – Filename of the input image to be transformed</p></li>
<li><p><strong>output_image_fname</strong> (<em>str</em>) – Filename of the output image after transformation. If None (default), it will be returned as a python variable but not written to disk.</p></li>
<li><p><strong>from_slice_name</strong> (<em>str</em>) – When transforming slice based image data only, we also need to know the filename of the slice the data came from.</p></li>
<li><p><strong>to_slice_name</strong> (<em>str</em>) – When transforming slice based image data only, we also need to know the filename of the slice the data came from.</p></li>
<li><p><strong>use_detjac</strong> (<em>bool</em>) – If the image represents a density, it should be transformed and multiplied by the Jacobian of the transformation</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>**kwargs</strong> (<em>dict</em>) – Arguments passed to torch interpolation (grid_resample), e.g. padding_mode,</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>phiI</strong> (<em>array</em>) – Transformed image</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>Exception</strong> – If use_detjac set to True for 3D to 2D mapping. Detjac not currently supported for 3D to 2D.</p></li>
<li><p><strong>Exception</strong> – 2D to 3D not implemented yet, may not get implemented.</p></li>
<li><p><strong>Exception</strong> – Jacobian not implemented yet for 2D slices.</p></li>
</ul>
</dd>
<dt class="field-odd">Warns</dt>
<dd class="field-odd"><p><strong>DetJac is ignored if mapping is 2D to 2D.</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.map_points">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">map_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">emlddmm_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_space_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_space_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_points_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_points_directory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_slice_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_slice_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_detjac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#map_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.map_points" title="Permalink to this definition"></a></dt>
<dd><p>For points we need to get the transforms in the opposite folder to images.</p>
<p>This function will map imaging data from one space to another.
There are four cases:</p>
<ol class="arabic simple">
<li><p>3D to 3D mapping: A single displacement field is used to map data</p></li>
<li><p>3D to 2D mapping: Currently not supported.</p></li>
<li><p>2D to 2D mapping: A single matrix is used to map data.</p></li>
<li><p>2D to 3D mapping: A single displacement field is used to map data, a slice filename is needed in addition to a space</p></li>
</ol>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function was built for a particular use case at Cold Spring Harbor, and is generally not used.
It may be removed in the future.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>emlddmm_path</strong> (<em>str</em>) – Path to the emlddmm python library, used for io</p></li>
<li><p><strong>root_dir</strong> (<em>str</em>) – The root directory of the output structure</p></li>
<li><p><strong>from_space_name</strong> (<em>str</em>) – The name of the space we are mapping data from</p></li>
<li><p><strong>to_space_name</strong> (<em>str</em>) – The name of the space we are mapping data to</p></li>
<li><p><strong>input_points_fname</strong> (<em>str</em>) – Filename of the input image to be transformed</p></li>
<li><p><strong>output_directory_fname</strong> (<em>str</em>) – Filename of the output image after transformation. If None (default), it will be returned as a python variable but not written to disk.</p></li>
<li><p><strong>from_slice_name</strong> (<em>str</em>) – When transforming slice based image data only, we also need to know the filename of the slice the data came from.</p></li>
<li><p><strong>to_slice_name</strong> (<em>str</em>) – When transforming slice based image data only, we also need to know the filename of the slice the data came from.</p></li>
<li><p><strong>use_detjac</strong> (<em>bool</em>) – If the image represents a density, it should be transformed and multiplied by the Jacobian of the transformation</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em>) – Arguments passed to torch interpolation (grid_resample), e.g. padding_mode,</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>phiP</strong> (<em>array</em>) – Transformed points</p></li>
<li><p><strong>connectivity</strong> (<em>list of lists</em>) – Same connectivity entries as loaded data</p></li>
<li><p><strong>connectivity_type</strong> (<em>str</em>) – Same connectivity type as loaded data</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Exception</strong> – 3D to 2D mapping is not implemented for points.</p></li>
<li><p><strong>Exception</strong> – If use_detjac set to True for 2D to 3D mapping. Detjac not currently supported for 2D to 3D</p></li>
<li><p><strong>Exception</strong> – If use_detjac set to True. Jacobian is not implemented yet.</p></li>
<li><p><strong>Exception</strong> – If attempting to map points from 3D to 2D.</p></li>
</ul>
</dd>
<dt class="field-even">Warns</dt>
<dd class="field-even"><p><strong>DetJac is ignored if mapping is 2D to 2D.</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.orientation_to_RAS">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">orientation_to_RAS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orientation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#orientation_to_RAS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.orientation_to_RAS" title="Permalink to this definition"></a></dt>
<dd><p>Compute a linear transform from a given orientation to RAS.</p>
<p>Orientations are specified using 3 letters, by selecting one of each
pair for each image axis: R/L, A/P, S/I</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>orientation</strong> (<em>3-tuple</em>) – orientation can be any iterable with 3 components.
Each component should be one of R/L, A/P, S/I. There should be no duplicates</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Ao</strong> (<em>3x3 numpy array</em>) – A linear transformation to transform your image to RAS</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.orientation_to_orientation">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">orientation_to_orientation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orientation0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#orientation_to_orientation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.orientation_to_orientation" title="Permalink to this definition"></a></dt>
<dd><p>Compute a linear transform from one given orientation to another.</p>
<p>Orientations are specified using 3 letters, by selecting one of each
pair for each image axis: R/L, A/P, S/I</p>
<p>This is done by computing transforms to and from RAS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>orientation</strong> (<em>3-tuple</em>) – orientation can be any iterable with 3 components.
Each component should be one of R/L, A/P, S/I. There should be no duplicates</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Ao</strong> (<em>3x3 numpy array</em>) – A linear transformation to transform your image from orientation0 to orientation1</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.pad">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">pad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xI</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#pad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.pad" title="Permalink to this definition"></a></dt>
<dd><p>Pad an image and its domain.</p>
<p>Perhaps include here</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xI</strong> (<em>list</em><em> of </em><em>arrays</em>) – Location of pixels in I</p></li>
<li><p><strong>I</strong> (<em>array</em>) – Image</p></li>
<li><p><strong>n</strong> (<em>list</em><em> of </em><em>ints</em><em> or </em><em>list</em><em> of </em><em>pairs</em><em> of </em><em>ints</em>) – Pad on front and back</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.project_affine_to_rigid">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">project_affine_to_rigid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">XJ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#project_affine_to_rigid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.project_affine_to_rigid" title="Permalink to this definition"></a></dt>
<dd><p>This function finds the closest rigid transform to the given affine transform.</p>
<p>Close is defined in terms of the action of A^{-1} on XJ</p>
<p>That is, we find R to minimize || A^{-1}XJ - R^{-1}XJ||^2_F = || R (A^{-1}XJ) - XJ ||^2_F.</p>
<p>We use a standard procurstes method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>torch tensor</em>) – A 4x4 affine transformation matrix</p></li>
<li><p><strong>XJ</strong> (<em>torch tensor</em>) – A 3 x slice x row x col array of coordinates in the space of the target image</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>R</strong> (<em>torch tensor</em>) – A 4x43 rigid affine transformation matrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.read_data">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">read_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#read_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.read_data" title="Permalink to this definition"></a></dt>
<dd><p>Read array data from several file types.</p>
<p>This function will read array based data of several types
and output x,images,title,names. Note we prefer vtk legacy format,
but accept some other formats as read by nibabel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>) – Filename (full path or relative) of array data to load. Can be .vtk or
nibabel supported formats (e.g. .nii)</p></li>
<li><p><strong>x</strong> (<em>list</em><em> of </em><em>arrays</em><em>, </em><em>optional</em>) – Coordinates for 2D series space</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em>) – Keyword parameters that are passed on to the loader function</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>x</strong> (<em>list of numpy arrays</em>) – Pixel locations where each element of the list identifies pixel
locations in corresponding axis.</p></li>
<li><p><strong>images</strong> (<em>numpy array</em>) – Imaging data of size channels x slices x rows x cols, or of size
time x 3 x slices x rows x cols for velocity fields</p></li>
<li><p><strong>title</strong> (<em>str</em>) – Title of the dataset (read from vtk files)</p></li>
<li><p><strong>names</strong> (<em>list of str</em>) – Names of each dataset (channel or time point)</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Exception</strong> – If file type is nrrd.</p></li>
<li><p><strong>Exception</strong> – If data is a single slice, json reader does not support it.</p></li>
<li><p><strong>Exception</strong> – If opening with Nibabel and the affine matrix is not diagonal.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.read_matrix_data">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">read_matrix_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#read_matrix_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.read_matrix_data" title="Permalink to this definition"></a></dt>
<dd><p>Read linear transforms as matrix text file.
Note in python we work in zyx order, but text files are in xyz order</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fname</strong> (<em>str</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>A</strong> (<em>array</em>) – matrix in zyx order</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.read_vtk_data">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">read_vtk_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'b'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#read_vtk_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.read_vtk_data" title="Permalink to this definition"></a></dt>
<dd><p>Read vtk structured points legacy format data.</p>
<p>Note endian should always be big, but we support little as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>) – Name of .vtk file to read.</p></li>
<li><p><strong>normalize</strong> (<em>bool</em>) – Whether or not to divide an image by its mean absolute value. Defaults to True.</p></li>
<li><p><strong>endian</strong> (<em>str</em>) – Endian of data, with ‘b’ for big (default and only officially supported format)
or ‘l’ for little (for compatibility if necessary).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>x</strong> (<em>list of numpy arrays</em>) – Location of voxels along each spatial axis (last 3 axes)</p></li>
<li><p><strong>images</strong> (<em>numpy array</em>) – Image with last three axes corresponding to spatial dimensions.  If 4D,
first axis is channel.  If 5D, first axis is time, and second is xyz
component of vector field.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Exception</strong> – The first line should include vtk DataFile Version X.X</p></li>
<li><p><strong>Exception</strong> – If the file contains data type other than BINARY.</p></li>
<li><p><strong>Exception</strong> – If the dataset type is not STRUCTURED_POINTS.</p></li>
<li><p><strong>Exception</strong> – If the dataset does not have either 3 or 4 axes.</p></li>
<li><p><strong>Exception</strong> – If dataset does not contain POINT_DATA</p></li>
<li><p><strong>Exception</strong> – If the file does not contain scalars or vectors.</p></li>
</ul>
</dd>
<dt class="field-even">Warns</dt>
<dd class="field-even"><p><strong>If data not written in big endian</strong> – Note (b) symbol not in data name {name}, you should check that it was written big endian. Specify endian=”l” if you want little</p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id17">
<p class="admonition-title">Todo</p>
<p>Torch does not support negative strides.  This has lead to an error where x has a negative stride.
I should flip instead of negative stride, or copy afterward.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.read_vtk_polydata">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">read_vtk_polydata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#read_vtk_polydata"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.read_vtk_polydata" title="Permalink to this definition"></a></dt>
<dd><p>Read ascii vtk polydata from simple legacy files.
Assume file contains xyz order, they are converted to zyx for python</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fname</strong> (<em>str</em>) – The name of the file to read</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>points</strong> (<em>numpy float array</em>) – nx3 array storing locations of points</p></li>
<li><p><strong>connectivity</strong> (<em>list of lists</em>) – list of indices containing connectivity elements</p></li>
<li><p><strong>connectivity_type</strong> (<em>str</em>) – VERTICES or LINES or POLYGONS</p></li>
<li><p><strong>name</strong> (<em>str</em>) – name of the dataset</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.registered_domain">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">registered_domain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A2d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#registered_domain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.registered_domain" title="Permalink to this definition"></a></dt>
<dd><p>Construct a new domain that fits all rigidly aligned slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>list</em><em> of </em><em>arrays</em>) – list of numpy arrays containing voxel positions along each axis.</p></li>
<li><p><strong>A2d</strong> (<em>numpy array</em>) – Nx3x3 array of affine transformations</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>xr</strong> (<em>list of arrays</em>) – new list of numpy arrays containing voxel positions along each axis</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.reshape_for_local">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">reshape_for_local</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_contrast</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#reshape_for_local"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.reshape_for_local" title="Permalink to this definition"></a></dt>
<dd><p>Reshapes an image into blocks for simple local contrast estimation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>J</strong> (<em>tensor</em>) – 3D image data where first index stores the channel information (i.e. 4D array)</p></li>
<li><p><strong>local_contrast</strong> (<em>tensor</em>) – 1D tensor storing the block size on each dimension</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Jv</strong> (<em>tensor</em>) – Reshaped imaging data to be used for contrast estimation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.reshape_from_local">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">reshape_from_local</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Jv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_contrast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#reshape_from_local"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.reshape_from_local" title="Permalink to this definition"></a></dt>
<dd><p>After changing contrast, transform back
TODO: this did not get used</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.rigid2D">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">rigid2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xI</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xJ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#rigid2D"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.rigid2D" title="Permalink to this definition"></a></dt>
<dd><p>Rigid transformation between 2D slices.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.sinc_resample_numpy">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">sinc_resample_numpy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#sinc_resample_numpy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.sinc_resample_numpy" title="Permalink to this definition"></a></dt>
<dd><p>Perform sinc resampling of an image in numpy.</p>
<p>This function does sinc resampling using numpy rfft
torch does not let us control behavior of fft well enough
This is intended to be used to resample velocity fields if necessary
Only intending it to be used for upsampling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>I</strong> (<em>numpy array</em>) – An image to be resampled. Can be an arbitrary number of dimensions.</p></li>
<li><p><strong>n</strong> (<em>list</em><em> of </em><em>ints</em>) – Desired dimension of output data.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Id</strong> (<em>numpy array</em>) – A resampled image of size n.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.v_to_phii">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">v_to_phii</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#v_to_phii"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.v_to_phii" title="Permalink to this definition"></a></dt>
<dd><p>Use Euler’s method to construct a position field from a velocity field
by integrating over time.</p>
<p>This method uses interpolation and subtracts and adds identity for better
behavior outside boundaries. This method is sometimes refered to as the
method of characteristics.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xv</strong> (<em>list</em><em> of </em><em>1D tensors</em>) – xv[i] is a tensor storing the location of the sample points along
the i-th dimension of v</p></li>
<li><p><strong>v</strong> (<em>5D tensor</em>) – 5D tensor where first axis corresponds to time, second corresponds to
component, and 3rd to 5th correspond to spatial dimensions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>phii</strong> (<em>4D tensor</em>) – Inverse transformation is output with component on the first dimension
and space on the last 3. Note that the whole timeseries is not output.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.weighted_intraclass_variance">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">weighted_intraclass_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bbox</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ji</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ellipse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#weighted_intraclass_variance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.weighted_intraclass_variance" title="Permalink to this definition"></a></dt>
<dd><p>Returns weighted intraclass variance (as in Otsu’s method) for an image with a given bounding box.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bbox</strong> (<em>list</em>) – A tuple of 4 ints. [row0, col0, row1, col1].</p></li>
<li><p><strong>Ji</strong> (<em>numpy array</em>) – Row x col x n_channels numpy array to find bounding box</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>E</strong> (<em>float</em>) – The weighted intraclass variance between inside and outside the bounding box.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.write_data">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">write_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#write_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.write_data" title="Permalink to this definition"></a></dt>
<dd><p>Write data</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Exception</strong> – If data is in .nii format, it must be grayscale.</p></li>
<li><p><strong>Exception</strong> – If output is not .vtk or .nii/.nii.gz format.</p></li>
</ul>
</dd>
<dt class="field-even">Warns</dt>
<dd class="field-even"><p><strong>If data to be written uses extension .nii or .nii.gz</strong> – Writing image in nii fomat, no title or names saved</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.write_matrix_data">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">write_matrix_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#write_matrix_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.write_matrix_data" title="Permalink to this definition"></a></dt>
<dd><p>Write linear transforms as matrix text file.
Note that in python we use zyx order,
but we write outputs in xyz order</p>
<div class="section" id="parameter">
<h3>Parameter<a class="headerlink" href="#parameter" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>fname<span class="classifier">str</span></dt><dd><p>Filename to write</p>
</dd>
<dt>A<span class="classifier">2D array</span></dt><dd><p>Matrix data to write. Assumed to be in zyx order.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">returns</dt>
<dd class="field-odd"><p><em>None</em></p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.write_outputs_for_pair">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">write_outputs_for_pair</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xI</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xJ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">WJ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atlas_space_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_space_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atlas_image_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_image_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#write_outputs_for_pair"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.write_outputs_for_pair" title="Permalink to this definition"></a></dt>
<dd><p>Write outputs in standard format for a pair of images</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output_dir</strong> (<em>str</em>) – Location to store output data.</p></li>
<li><p><strong>outputs</strong> (<em>dict</em>) – Dictionary of outputs from the emlddmm python code</p></li>
<li><p><strong>xI</strong> (<em>list</em><em> of </em><em>numpy array</em>) – Location of voxels in atlas</p></li>
<li><p><strong>I</strong> (<em>numpy array</em>) – Atlas image</p></li>
<li><p><strong>xJ</strong> (<em>list</em><em> of </em><em>numpy array</em>) – Location of voxels in target</p></li>
<li><p><strong>J</strong> (<em>numpy array</em>) – Target image</p></li>
<li><p><strong>atlas_space_name</strong> (<em>str</em>) – Name of atlas space (default ‘atlas’)</p></li>
<li><p><strong>target_space_name</strong> (<em>str</em>) – Name of target space (default ‘target’)</p></li>
<li><p><strong>atlas_image_name</strong> (<em>str</em>) – Name of atlas image (default ‘atlasimage’)</p></li>
<li><p><strong>target_image_name</strong> (<em>str</em>) – Name of target image (default ‘targetimage’)</p></li>
</ul>
</dd>
</dl>
<div class="admonition-todo admonition" id="id18">
<p class="admonition-title">Todo</p>
<p>Implement QC figures.</p>
<p>Check device more carefully, probably better to put everything on cpu.</p>
<p>Check dtype more carefully.</p>
<p>Get determinant of jacobian. (done)</p>
<p>Write velocity out and affine</p>
<p>Get a list of files to name outputs.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.write_qc_outputs">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">write_qc_outputs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xS</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#write_qc_outputs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.write_qc_outputs" title="Permalink to this definition"></a></dt>
<dd><p>write out registration qc images</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output_dir</strong> (<em>string</em>) – Path to output parent directory</p></li>
<li><p><strong>output</strong> (<em>dict</em>) – Output dictionary from emlddmm algorithm</p></li>
<li><p><strong>I</strong> (<em>emlddmm image</em>) – source image</p></li>
<li><p><strong>J</strong> (<em>emlddmm image</em>) – target image</p></li>
<li><p><strong>xS</strong> (<em>list</em><em> of </em><em>arrays</em><em>, </em><em>optional</em>) – Label coordinates</p></li>
<li><p><strong>S</strong> (<em>array</em><em>, </em><em>optional</em>) – Labels</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>None</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.write_transform_outputs">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">write_transform_outputs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">J</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#write_transform_outputs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.write_transform_outputs" title="Permalink to this definition"></a></dt>
<dd><p>Note, daniel is redoing the above slightly. on March 2023</p>
<p>Write transforms output from emlddmm.  Velocity field, 3D affine transform,
and 2D affine transforms for each slice if applicable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output_dir</strong> (<em>str</em>) – Directory to place output data (will be created of it does not exist)</p></li>
<li><p><strong>output</strong> (<em>dict</em>) – Output dictionary from emlddmm algorithm</p></li>
<li><p><strong>A2d_names</strong> (<em>list</em>) – List of file names for A2d transforms</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>None</em></p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id19">
<p class="admonition-title">Todo</p>
<p>Update parameter list.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.write_transform_outputs_">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">write_transform_outputs_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">J</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#write_transform_outputs_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.write_transform_outputs_" title="Permalink to this definition"></a></dt>
<dd><p>Note this version (whose function name ends in “_” ) is obsolete.
Write transforms output from emlddmm.  Velocity field, 3D affine transform,
and 2D affine transforms for each slice if applicable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output_dir</strong> (<em>str</em>) – Directory to place output data (will be created of it does not exist)</p></li>
<li><p><strong>output</strong> (<em>dict</em>) – Output dictionary from emlddmm algorithm</p></li>
<li><p><strong>A2d_names</strong> (<em>list</em>) – List of file names for A2d transforms</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>None</em></p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id20">
<p class="admonition-title">Todo</p>
<p>Update parameter list.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.write_vtk_data">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">write_vtk_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#write_vtk_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.write_vtk_data" title="Permalink to this definition"></a></dt>
<dd><p>Write data as vtk file legacy format file. Note data is written in big endian.</p>
<p>inputs should be numpy, but will check for tensor
only structured points supported, scalars or vectors data type
each channel is saved as a dataset (time for velocity field, or image channel for images)
each channel is saved as a structured points with a vector or a scalar at each point</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>) – filename to write to</p></li>
<li><p><strong>x</strong> (<em>list</em><em> of </em><em>arrays</em>) – Voxel locations along last three axes</p></li>
<li><p><strong>out</strong> (<em>numpy array</em>) – Imaging data to write out. If out is size nt x 3 x slices x height x width we assume vector
if out is size n x slices x height x width we assume scalar</p></li>
<li><p><strong>title</strong> (<em>str</em>) – Name of the dataset</p></li>
<li><p><strong>names</strong> (<em>list</em><em> of </em><em>str</em><em> or </em><em>None</em>) – List of names for each dataset or None to use a default.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>Exception</strong> – If out is not the right size.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="emlddmm.write_vtk_polydata">
<span class="sig-prename descclassname"><span class="pre">emlddmm.</span></span><span class="sig-name descname"><span class="pre">write_vtk_polydata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/emlddmm.html#write_vtk_polydata"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#emlddmm.write_vtk_polydata" title="Permalink to this definition"></a></dt>
<dd><p>points should by Nx3 in zyx order
It will be written out in xyz order
connectivity should be lists of indices or nothing to write only cell data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>) – Filename to write</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Dataset name</p></li>
<li><p><strong>points</strong> (<em>array</em>) – </p></li>
<li><p><strong>connectivity</strong> (<em>str</em>) – Array of arrays storing each connectivity element as integers that refer to the points,
size number of points by number of dimensions (expected to be 3)</p></li>
<li><p><strong>connectivity_type</strong> (<em>str</em>) – Can by VERTICES, or POLYGONS, or LINES</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>nothing</em></p>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Daniel Tward.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>